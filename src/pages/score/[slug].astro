---
import Layout from '../../layouts/Layout.astro';
import PageHeader from '../../components/PageHeader.astro';
import Error404 from '../../components/Error404.astro';
import { getScoreBySlug, getScore } from '../../api/scores';
import { GitFork, SquarePen, Trash2 } from '@lucide/astro';

// In server mode, this page SSRs all routes dynamically
// (getStaticPaths not used - all score URLs render on-demand)
const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/');
}

// Server-side fetch
const scoreResult = await getScoreBySlug(slug);
const { score } = scoreResult;

if (!score) {
  Astro.response.status = 404;
}

// Fetch parent score if forked
let parentScore = null;
if (score?.forked_from) {
  const parentResult = await getScore(score.forked_from);
  parentScore = parentResult.score;
}
---

{score ? (
<Layout title={`${score.title} - Shakuhachi Score Library`} currentPage="score" fullHeight={true}>
  <!-- Score metadata in header -->
  <PageHeader slot="header-metadata" title={score.title}>
    {parentScore ? (
      <span>
        forked from <a href={`/score/${parentScore.slug}`}>{parentScore.title}</a>
      </span>
    ) : (
      <span class="score-stat">
        updated <relative-time datetime={score.created_at} format="relative"></relative-time>
      </span>
    )}
  </PageHeader>

  <!-- Header actions (right side of navbar) -->
  <div slot="header-actions" style="display: flex; gap: var(--spacing-small); align-items: center;">
    <!-- Owner-only edit button -->
    <a href={`/score/${score.slug}/edit`}
       class="btn btn-icon"
       id="edit-btn"
       aria-label="Edit score"
       style="display: none;">
      <SquarePen size={16} />
    </a>

    <!-- Owner-only delete button -->
    <button id="delete-btn"
            class="btn btn-icon"
            aria-label="Delete score"
            style="display: none;">
      <Trash2 size={16} />
    </button>

    <!-- Fork button -->
    <button id="fork-btn"
            class="btn btn-icon-with-count"
            aria-label="Fork this score"
            title="Create your own editable copy of this score">
      <GitFork size={16} />
      <span class="count">{score.fork_count}</span>
    </button>
  </div>

  <!-- Score content -->
  <div class="score-detail-container">

    <!-- Score renderer using web component -->
    <shakuhachi-score id="score-renderer"></shakuhachi-score>

    <!-- Attribution section (only for scores with attribution data) -->
    {(score.source_url || score.rights || score.source_description) && (
      <section class="score-attribution">
        <h3>Attribution</h3>
        {score.source_description && <p class="attribution-description">{score.source_description}</p>}
        <div class="attribution-meta">
          {score.rights && <span class="attribution-rights">{score.rights}</span>}
          {score.source_url && (
            <a href={score.source_url} target="_blank" rel="noopener noreferrer" class="attribution-link">
              Source Reference
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" x2="21" y1="14" y2="3"/></svg>
            </a>
          )}
        </div>
      </section>
    )}
  </div>

  <!-- Embed score data for client -->
  <script id="score-data" type="application/json" is:inline set:html={JSON.stringify({ score, parentScore })}></script>

  <!-- Load web component for score rendering -->
  <script is:inline src="/embed/shakuhachi-score.js"></script>

  <!-- Initialize relative-time web component -->
  <script>
    import '@github/relative-time-element';
  </script>

  <!-- Initialize theme switcher and auth widget -->
  <script>
    import { createElement, Book, Plus, Info, SunMoon, SquarePen, Trash2 } from 'lucide';
    import { ThemeSwitcher } from '../../components/ThemeSwitcher';
    import { AuthWidget } from '../../components/AuthComponents';
    import { onAuthReady } from '../../api/auth';
    import { MobileMenu, type MenuItem } from '../../components/MobileMenu';

    // Initialize theme switcher
    new ThemeSwitcher('theme-switcher');

    // Initialize auth widget
    const authWidget = new AuthWidget('auth-widget');

    // Subscribe to auth changes - onAuthReady handles deduplication
    onAuthReady((user) => {
      authWidget.setUser(user);
    });

    // Helper to generate Lucide icon HTML
    const getIconHTML = (iconComponent: typeof Book) => {
      const icon = createElement(iconComponent);
      icon.setAttribute('width', '16');
      icon.setAttribute('height', '16');
      icon.setAttribute('stroke-width', '2');
      return icon.outerHTML;
    };

    // Initialize mobile menu
    const toggleTheme = () => {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
    };

    const mobileMenu = new MobileMenu('mobile-menu');

    // Function to update mobile menu items based on auth state
    const updateMobileMenuItems = (isOwner: boolean) => {
      const baseItems: MenuItem[] = [
        {
          id: 'browse',
          label: 'Library',
          href: '/',
          icon: getIconHTML(Book),
          dividerAfter: false,
        },
        {
          id: 'create',
          label: 'Create score',
          href: '/editor',
          icon: getIconHTML(Plus),
          dividerAfter: false,
        },
        {
          id: 'about',
          label: 'About',
          href: '/about',
          icon: getIconHTML(Info),
          dividerAfter: !isOwner, // Add divider if no edit button follows
        },
      ];

      // Add edit and delete buttons if user owns the score
      if (isOwner) {
        const editBtn = document.getElementById('edit-btn') as HTMLAnchorElement;
        if (editBtn) {
          baseItems.push({
            id: 'edit',
            label: 'Edit score',
            href: editBtn.href,
            icon: getIconHTML(SquarePen),
            dividerAfter: false,
          });
        }
        baseItems.push({
          id: 'delete',
          label: 'Delete score',
          action: () => (document.getElementById('delete-btn') as HTMLButtonElement)?.click(),
          icon: getIconHTML(Trash2),
          dividerAfter: true,
        });
      }

      baseItems.push({
        id: 'theme',
        label: 'Toggle theme',
        action: toggleTheme,
        icon: getIconHTML(SunMoon),
        dividerAfter: false,
      });

      mobileMenu.setItems(baseItems);
    };

    // Get score data to check ownership
    const dataEl = document.getElementById('score-data');
    if (dataEl) {
      try {
        const data = JSON.parse(dataEl.textContent || '{}');
        const score = data.score;

        // Subscribe to auth changes - onAuthReady handles deduplication
        onAuthReady((user) => {
          const isOwner = !!(user && score && user.id === score.user_id);
          updateMobileMenuItems(isOwner);
        });
      } catch (error) {
        console.error('Failed to parse score data for menu:', error);
        updateMobileMenuItems(false);
      }
    } else {
      updateMobileMenuItems(false);
    }
  </script>

  <!-- Client-side logic -->
  <script>
    import { ScoreDetailClient } from '../../components/ScoreDetailClient';
    const client = new ScoreDetailClient();
    client.init();
  </script>

  <style>
    :global(.metadata-separator) {
      color: var(--color-separator);
    }

    :global(.score-stat) {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-3x-small);
    }

    :global(.score-header-metadata a) {
      color: var(--color-link);
      text-decoration: none;
    }

    :global(.score-header-metadata a:hover) {
      text-decoration: underline;
    }

    /* Page content styling */
    .score-detail-container {
      width: 100%; /* Fill viewport width */
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--spacing-large) var(--spacing-large) 0;
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      box-sizing: border-box; /* Include padding in width calculation */
    }

    #score-renderer {
      /* Flex child - fills available space in parent flex container */
      flex: 1;
      /* Needed for custom elements to participate in flex layout */
      display: block;
      min-height: 0; /* Allow flex shrinking */
      /* Fill parent dimensions (parent is flex container) */
      width: 100%;
      align-self: stretch; /* Stretch to fill cross axis */
    }

    /* Attribution section */
    .score-attribution {
      margin-top: var(--spacing-large);
      padding: var(--spacing-medium);
      background: var(--color-surface-elevated);
      border-radius: var(--border-radius);
      border: 1px solid var(--color-border);
    }

    .score-attribution h3 {
      margin: 0 0 var(--spacing-small) 0;
      font-size: var(--font-size-small);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .attribution-description {
      margin: 0 0 var(--spacing-small) 0;
      font-size: var(--font-size-small);
      color: var(--color-text-primary);
      line-height: 1.5;
    }

    .attribution-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-medium);
      align-items: center;
      font-size: var(--font-size-x-small);
    }

    .attribution-rights {
      display: inline-flex;
      align-items: center;
      padding: var(--spacing-3x-small) var(--spacing-small);
      background: var(--color-success-background);
      color: var(--color-success);
      border-radius: var(--border-radius-small);
      font-weight: var(--font-weight-medium);
    }

    .attribution-link {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-3x-small);
      color: var(--color-link);
      text-decoration: none;
    }

    .attribution-link:hover {
      text-decoration: underline;
    }

    .attribution-link svg {
      flex-shrink: 0;
    }

    /* Responsive */
    @media (max-width: 768px) {
      :global(.score-header-metadata) {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--spacing-2x-small);
      }

      :global(.score-title) {
        font-size: var(--font-size-medium);
      }

      /* Hide desktop edit button on mobile - shown in menu instead */
      :global(#edit-btn) {
        display: none !important;
      }

      .floating-edit-btn {
        top: 120px;
        right: var(--spacing-medium);
      }

      /* Mobile score rendering - allow natural height expansion */
      .score-detail-container {
        flex: none; /* Remove flex constraint */
        overflow: visible; /* Allow content to overflow viewport */
        padding: var(--spacing-medium) var(--spacing-small) 0;
        max-width: 100%; /* Constrain to viewport width */
      }

      #score-renderer-container {
        flex: none; /* Remove flex constraint */
        min-height: auto; /* Allow natural height */
        width: 100%; /* Full width of container */
      }

    }
  </style>
</Layout>
) : (
<Layout title="Page Not Found - Shakuhachi.ro" currentPage="score">
  <PageHeader slot="header-metadata" title="Page Not Found" />
  <Error404 />
</Layout>
)}
