<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Akatombo - Full Score</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸªˆ</text></svg>"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Noto Sans JP', 'Noto Sans', sans-serif;
        background: white;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      header {
        flex-shrink: 0;
        padding: 20px 40px;
      }

      h1 {
        font-size: 1.5rem;
        margin-bottom: 10px;
        font-weight: 300;
      }

      .subtitle {
        color: #666;
        font-size: 0.9rem;
      }

      #display {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow: auto;
      }

      #display.debug svg {
        border: 2px solid #e74c3c;
      }

      .error {
        color: #e74c3c;
        padding: 20px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Akatombo - Full Score</h1>
      <p class="subtitle">
        All notes from MusicXML rendered vertically
        <span id="debug-indicator"></span>
      </p>
    </header>

    <div id="display"></div>

    <script type="module">
      import { MusicXMLParser } from '/src/parser/MusicXMLParser';
      import { ScoreParser } from '/src/parser/ScoreParser';
      import { SVGRenderer } from '/src/renderer/SVGRenderer';

      const display = document.getElementById('display');

      // Check for debug query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const showRomanji =
        urlParams.get('debug') === 'true' ||
        urlParams.get('romanji') === 'true';
      const showOctaveMarks = urlParams.get('octaveMarks') !== 'false'; // Show by default

      if (showRomanji) {
        console.log('Debug mode: Romanji labels enabled');
        document.getElementById('debug-indicator').innerHTML =
          'Debug: ON - ?debug=true found in URL';
        display.classList.add('debug');
      }

      console.log(`Octave marks: ${showOctaveMarks ? 'enabled' : 'disabled'}`);

      async function renderFirstColumn() {
        try {
          console.log('Loading Akatombo from MusicXML...');

          // Parse MusicXML file
          const scoreData = await MusicXMLParser.parseFromURL(
            '/data/Akatombo.musicxml'
          );
          console.log('Parsed MusicXML:', scoreData);
          console.log('Total notes:', scoreData.notes.length);

          // Convert to ShakuNote objects using ScoreParser
          const allNotes = ScoreParser.parse(scoreData);
          console.log(`Converted to ${allNotes.length} ShakuNote objects`);

          // Render ALL notes in a single column
          const firstColumnNotes = allNotes;
          console.log('Rendering all notes:', firstColumnNotes.length);

          // Debug: log each note's modifiers
          firstColumnNotes.forEach((note, i) => {
            const mods = note.getModifiers();
            console.log(
              `Note ${i} (${note.getKana()}):`,
              mods.length,
              'modifiers',
              mods
            );

            // Remove octave marks if disabled, otherwise configure them
            if (!showOctaveMarks) {
              // Remove octave mark modifiers from the note
              const nonOctaveModifiers = mods.filter(
                (mod) => mod.constructor.name !== 'OctaveMarksModifier'
              );
              note.modifiers = nonOctaveModifiers;
            } else {
              // Configure octave stroke marks
              mods.forEach((mod) => {
                if (mod.constructor.name === 'OctaveMarksModifier') {
                  mod
                    .setStrokeLength(6) // Length of stroke mark
                    .setStrokeWidth(1.5) // Stroke thickness
                    .setColor('#000'); // Black
                }
              });
            }
          });

          // Create SVG renderer - fit to viewport
          const displayRect = display.getBoundingClientRect();
          const svgWidth = displayRect.width;
          const svgHeight = displayRect.height;
          const renderer = new SVGRenderer(display, svgWidth, svgHeight);
          console.log(`SVG size: ${svgWidth}x${svgHeight}`);

          // Multi-column layout configuration
          const columnWidth = 100; // Width for each column
          const columnSpacing = 55; // Space between columns (reduced to match reference)
          const notesPerColumn = 10; // Notes per column
          const startY = 70; // Top margin (reduced to match reference)
          const verticalSpacing = 48; // Fixed spacing between notes (reduced to match reference)
          const fontSize = 28; // Font size for notes (reduced to match reference)

          // Calculate number of columns needed
          const totalColumns = Math.ceil(
            firstColumnNotes.length / notesPerColumn
          );
          console.log(
            `Rendering ${firstColumnNotes.length} notes in ${totalColumns} columns`
          );

          // Calculate starting X position (center the score horizontally)
          const actualTotalWidth = totalColumns * columnWidth + (totalColumns - 1) * columnSpacing;
          const startX = (svgWidth - actualTotalWidth) / 2 + columnWidth / 2;

          // Render each column from right to left
          for (let col = 0; col < totalColumns; col++) {
            // Reverse column order: first column (col=0) is rightmost
            const columnX =
              startX + (totalColumns - 1 - col) * (columnWidth + columnSpacing);
            const startIndex = col * notesPerColumn;
            const endIndex = Math.min(
              startIndex + notesPerColumn,
              firstColumnNotes.length
            );
            const columnNotes = firstColumnNotes.slice(startIndex, endIndex);

            console.log(
              `Column ${col + 1}: notes ${
                startIndex + 1
              }-${endIndex} at x=${columnX}`
            );

            // Render notes in this column
            columnNotes.forEach((note, index) => {
              const y = startY + index * verticalSpacing;
              note.setFontSize(fontSize); // Apply consistent font size
              note.setPosition(columnX, y);
              note.render(renderer);

              // Debug: render romanji label and note number to the right
              if (showRomanji) {
                const symbolInfo = note.getSymbolInfo();
                const romanji = symbolInfo?.romaji || 'unknown';
                const octave = note
                  .getModifiers()
                  .some((m) => m.constructor.name === 'OctaveMarksModifier')
                  ? '(kan)'
                  : '';
                const globalIndex = startIndex + index;
                const label = `#${globalIndex + 1} ${romanji} ${octave}`.trim();

                renderer.drawText(
                  label,
                  columnX + 40, // Position to the right of the note
                  y + 5, // Slightly below baseline
                  12, // Small font size
                  'monospace', // Monospace font for alignment
                  '#999' // Gray color
                );
              }
            });
          }

          console.log('Multi-column layout rendered from MusicXML!');
        } catch (error) {
          console.error('Error:', error);
          display.innerHTML = `<div class="error">Error: ${error.message}<br><br>Stack: ${error.stack}</div>`;
        }
      }

      // Render when page loads
      renderFirstColumn();
    </script>
  </body>
</html>
